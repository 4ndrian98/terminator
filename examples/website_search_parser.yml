---
# Example workflow that searches Google and extracts results
# Demonstrates the standardized success/failure pattern with output parser
tool_name: execute_sequence
arguments:
  variables:
    search_query:
      type: string
      label: Search Query
      default: "Rust programming language"
      required: true
    
  inputs:
    search_query: "Rust programming language"
    
  selectors:
    # Google-specific selectors
    search_box: "role:ComboBox|name:Search"
    search_button: "role:Button|name:Google Search"
    
  steps:
    # Open browser and navigate to Google
    - tool_name: open_application
      arguments:
        app_name: "chrome"
      continue_on_error: true
      delay_ms: 2000

    - tool_name: navigate_browser
      arguments:
        url: "https://www.google.com"
        include_tree: false
      delay_ms: 3000

    # Perform search
    - tool_name: type_into_element
      arguments:
        selector: "${{ selectors.search_box }}"
        text_to_type: "${{ inputs.search_query }}"
        clear_before_typing: true
      delay_ms: 500

    - tool_name: press_key_global
      arguments:
        key: "{Enter}"
      delay_ms: 3000

    # Capture search results page
    - tool_name: get_focused_window_tree
      arguments:
        random_string: "capture_results"
      id: "search_results"

  output_parser:
    ui_tree_source_step_id: "search_results"
    javascript_code: |
      // Standard success/failure pattern for search results extraction
      
      // Initialize result structure
      const results = [];
      const errors = [];
      
      // Helper function to safely extract text
      function getText(element) {
        return element.attributes?.name || '';
      }
      
      // Check for error conditions first
      function checkForErrors(element) {
        const text = getText(element).toLowerCase();
        
        // Common error indicators
        if (text.includes('no results found') || 
            text.includes('did not match any documents') ||
            text.includes('error') && text.includes('occurred')) {
          errors.push(text);
          return true;
        }
        
        // Recursively check children
        if (element.children) {
          for (const child of element.children) {
            if (checkForErrors(child)) return true;
          }
        }
        return false;
      }
      
      // Extract search results
      function extractResults(element, depth = 0) {
        // Avoid infinite recursion
        if (depth > 10) return;
        
        // Look for elements that appear to be search results
        // Google typically uses specific patterns
        if (element.attributes) {
          const role = element.attributes.role;
          const name = element.attributes.name;
          
          // Look for links that appear to be search results
          if (role === 'Link' && name && 
              !name.toLowerCase().includes('google') &&
              !name.toLowerCase().includes('sign in') &&
              !name.toLowerCase().includes('settings') &&
              name.length > 10) {
            
            // Try to find associated description
            let description = '';
            if (element.parent && element.parent.children) {
              for (const sibling of element.parent.children) {
                if (sibling.attributes?.role === 'Text' && 
                    sibling.attributes?.name &&
                    sibling !== element) {
                  description = sibling.attributes.name;
                  break;
                }
              }
            }
            
            results.push({
              title: name,
              url: element.attributes.href || 'No URL',
              description: description || 'No description available'
            });
          }
        }
        
        // Recursively process children
        if (element.children) {
          for (const child of element.children) {
            extractResults(child, depth + 1);
          }
        }
      }
      
      // Main processing
      const hasErrors = checkForErrors(tree);
      
      if (!hasErrors) {
        extractResults(tree);
      }
      
      // Determine success based on results
      const success = results.length > 0 && errors.length === 0;
      
      // Build standardized response
      const response = {
        success: success,
        data: results,
        message: success 
          ? `Successfully extracted ${results.length} search results for "${inputs?.search_query || 'query'}"` 
          : errors.length > 0
            ? `Search failed: ${errors[0]}`
            : "No search results found - page may not have loaded correctly",
        error: errors.length > 0 ? errors.join('; ') : null,
        validation: {
          results_found: results.length,
          has_errors: errors.length > 0,
          page_loaded: tree.children && tree.children.length > 0,
          search_query: inputs?.search_query || 'unknown'
        }
      };
      
      return response;

  stop_on_error: false
  include_detailed_results: false
