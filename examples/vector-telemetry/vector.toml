# Vector configuration for collecting OpenTelemetry from MCP server
# This config:
# 1. Receives OTLP traces via HTTP
# 2. Parses and transforms the data
# 3. Outputs to console in a readable format

# OTLP HTTP source - receives traces from MCP server
[sources.otlp_traces]
type = "opentelemetry"
http.address = "0.0.0.0:4318"  # Listen on port 4318 for OTLP/HTTP

# Transform to extract useful information from spans
[transforms.parse_spans]
type = "remap"
inputs = ["otlp_traces"]
source = '''
# Extract key span information
.span_name = .name
.span_kind = .kind
.duration_ms = round((to_int!(.end_time_unix_nano) - to_int!(.start_time_unix_nano)) / 1000000)

# Extract workflow and step attributes
if exists(.attributes) {
  .workflow_name = .attributes."workflow.name"
  .tool_name = .attributes."tool.name"
  .step_number = .attributes."step.number"
  .step_total = .attributes."step.total"
  .step_id = .attributes."step.id"
}

# Extract service info from resource
if exists(.resource.attributes) {
  .service = .resource.attributes."service.name"
}

# Add timestamp
.timestamp = now()

# Clean up the output
del(.attributes)
del(.resource)
del(.start_time_unix_nano)
del(.end_time_unix_nano)
del(.trace_state)
del(.flags)
del(.links)
'''

# Filter to only show important spans (workflow and steps)
[transforms.filter_important]
type = "filter"
inputs = ["parse_spans"]
condition = '''
starts_with!(.span_name, "workflow.") || starts_with!(.span_name, "step.")
'''

# Console output with nice formatting
[sinks.console]
type = "console"
inputs = ["filter_important"]
encoding.codec = "json"
framing.method = "newline_delimited"

# Also create a simpler text output
[transforms.format_text]
type = "remap"
inputs = ["filter_important"]
source = '''
if starts_with!(.span_name, "workflow.") {
  .message = "üéØ WORKFLOW: " + string!(.workflow_name) + " (" + to_string!(.duration_ms) + "ms)"
} else if starts_with!(.span_name, "step.") {
  .message = "  üìç STEP " + to_string!(.step_number) + "/" + to_string!(.step_total) + ": " + string!(.tool_name) + " (" + to_string!(.duration_ms) + "ms)"
} else {
  .message = "  " + string!(.span_name)
}
'''

[sinks.console_text]
type = "console"
inputs = ["format_text"]
encoding.codec = "text"
encoding.only_fields = ["message"]

# Optional: Save to file for analysis
[sinks.file_json]
type = "file"
inputs = ["parse_spans"]
path = "./telemetry-output.json"
encoding.codec = "json"
framing.method = "newline_delimited"

# Metrics about the telemetry pipeline
[sinks.internal_metrics]
type = "internal_metrics"

[transforms.metrics_to_console]
type = "log_to_metric"
inputs = ["otlp_traces"]
metrics = [
  {
    type = "counter"
    field = "span_name"
    name = "spans_received"
    namespace = "telemetry"
    tags.span_type = "{{ span_name }}"
  }
]