---
tool_name: execute_sequence
arguments:
  steps:
    - tool_name: run_command
      arguments:
        unix_command: |
          bash -lc '
          set -euo pipefail
          EXT_DIR="$HOME/.terminator/bridge-extension"
          mkdir -p "$EXT_DIR"
          # Write manifest.json
          cat > "$EXT_DIR/manifest.json" <<'EOF'
          {
            "manifest_version": 3,
            "name": "Terminator Bridge",
            "description": "Bridge to evaluate JS in the active tab via a local WebSocket (no DevTools UI).",
            "version": "0.1.0",
            "permissions": [
              "debugger",
              "tabs",
              "scripting",
              "activeTab"
            ],
            "host_permissions": [
              "<all_urls>"
            ],
            "background": {
              "service_worker": "worker.js",
              "type": "module"
            },
            "action": {
              "default_title": "Terminator Bridge"
            }
          }
          EOF
          # Write worker.js
          cat > "$EXT_DIR/worker.js" <<'EOF'
          const WS_URL = 'ws://127.0.0.1:17373';
          let socket = null;
          let reconnectTimer = null;
          function log(...args) { console.log('[TerminatorBridge]', ...args); }
          function connect() {
            try { socket = new WebSocket(WS_URL); } catch (e) { log('WebSocket construct error', e); scheduleReconnect(); return; }
            socket.onopen = () => { log('Connected to', WS_URL); try { socket.send(JSON.stringify({ type: 'hello', from: 'extension' })); } catch(_){} };
            socket.onclose = () => { log('Socket closed'); scheduleReconnect(); };
            socket.onerror = (e) => { log('Socket error', e); try { socket.close(); } catch (_) {} };
            socket.onmessage = async (event) => {
              let msg; try { msg = JSON.parse(event.data); } catch (e) { log('Invalid JSON', event.data); return; }
              if (!msg || !msg.action) return;
              if (msg.action === 'eval') {
                const { id, code, awaitPromise = true } = msg;
                try {
                  const tabId = await getActiveTabId();
                  const result = await evalInTab(tabId, code, awaitPromise);
                  safeSend({ id, ok: true, result });
                } catch (err) {
                  safeSend({ id, ok: false, error: String(err && (err.message || err)) });
                }
              } else if (msg.action === 'ping') {
                safeSend({ type: 'pong' });
              }
            };
          }
          function scheduleReconnect() { if (reconnectTimer) return; reconnectTimer = setTimeout(() => { reconnectTimer = null; connect(); }, 1500); }
          function safeSend(obj) { try { if (socket && socket.readyState === WebSocket.OPEN) { socket.send(JSON.stringify(obj)); } } catch (e) { log('Failed to send', e); } }
          async function getActiveTabId() { const [tab] = await chrome.tabs.query({ active: true, lastFocusedWindow: true }); if (!tab || tab.id == null) throw new Error('No active tab'); return tab.id; }
          async function evalInTab(tabId, code, awaitPromise) {
            await debuggerAttach(tabId);
            try {
              await sendCommand(tabId, 'Runtime.enable', {});
              const { result, exceptionDetails } = await sendCommand(tabId, 'Runtime.evaluate', { expression: code, awaitPromise: !!awaitPromise, returnByValue: true, userGesture: true });
              if (exceptionDetails) { throw new Error(exceptionDetails.text || 'Evaluation error'); }
              return result?.value;
            } finally { try { await debuggerDetach(tabId); } catch (_) {} }
          }
          function debuggerAttach(tabId) { return new Promise((resolve, reject) => { chrome.debugger.attach({ tabId }, '1.3', () => { if (chrome.runtime.lastError) return reject(chrome.runtime.lastError); resolve(); }); }); }
          function debuggerDetach(tabId) { return new Promise((resolve) => { chrome.debugger.detach({ tabId }, () => resolve()); }); }
          function sendCommand(tabId, method, params) { return new Promise((resolve, reject) => { chrome.debugger.sendCommand({ tabId }, method, params, (result) => { const err = chrome.runtime.lastError; if (err) return reject(err); resolve(result || {}); }); }); }
          connect();
          EOF
          echo "✅ Extension files written to $EXT_DIR"
          '

    - tool_name: run_command
      arguments:
        unix_command: |
          bash -lc '
          set -euo pipefail
          EXT_DIR="$HOME/.terminator/bridge-extension"
          # Try to find a Chromium-based browser and launch with the extension
          BROWSER=""
          for CAND in google-chrome google-chrome-stable chromium chromium-browser microsoft-edge-beta microsoft-edge; do
            if command -v "$CAND" >/dev/null 2>&1; then BROWSER="$CAND"; break; fi
          done
          if [ -z "$BROWSER" ]; then echo "❌ No Chromium-based browser found (google-chrome/chromium/edge)" >&2; exit 1; fi
          echo "🚀 Launching $BROWSER with Terminator Bridge extension..."
          nohup "$BROWSER" --load-extension="$EXT_DIR" --no-first-run --new-window "https://example.com" >/dev/null 2>&1 &
          disown || true
          '

    - tool_name: delay
      arguments:
        delay_ms: 4000

    # Optional: open extensions page to verify (non-blocking)
    - tool_name: run_command
      continue_on_error: true
      arguments:
        unix_command: |
          bash -lc '
          for CAND in google-chrome google-chrome-stable chromium chromium-browser microsoft-edge-beta microsoft-edge; do
            if pkill -0 -f "$CAND" 2>/dev/null; then "$CAND" --new-window "chrome://extensions" >/dev/null 2>&1 & break; fi
          done
          '

  stop_on_error: true